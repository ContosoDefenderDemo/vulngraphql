{% extends 'partials/solutions/solution_base.html' %}
<!-- Start -->
{% block title %}GraphQL Query Deny List Bypass{% endblock %}

{% block body %}
  <p>
    Creating an <b>allow-list</b> or <b>deny-list</b> for GraphQL is a common technique to prevent malicious queries from
    being resolved by GraphQL.
  </p>
  <ul>
    <li>
      By defining an <b>allow-list</b>, the application server will have a "known good" queries it will allow, and
      reject anything else.
    </li>
    <li>
      By defining a <b>deny-list</b>, the application server will have a "known bad" queries it will reject, and allow
      anything else.
    </li>
  </ul>
  <p>
    In general, the allow-list approach is easier to maintain and less error-prone, since we only allow certain things we
    trust. It does not mean it cannot have flaws too.
  </p>
  <p>
    The application has a deny-list mechanism implemented that attempts to reject Health queries using the
    <code>systemHealth</code> query.
  </p>
  <p>
    The problem with this mechanism is that it does not take into consideration queries can have <a href="https://graphql.org/learn/queries/#operation-name" target="_blank">operation names</a>.
  </p>
{% endblock %}

{% block resources %}
  <li>
    <a href="https://www.apollographql.com/blog/securing-your-graphql-api-from-malicious-queries-16130a324a6b/" target="_blank">
      <i class="fa fa-newspaper"></i> Apollo - Securing your GraphQL From Malicious Queries
    </a>
  </li>
  <li>
    <a href="https://cwe.mitre.org/data/definitions/184.html" target="_blank">
      <i class="fa fa-newspaper"></i> CWE-184: Incomplete List of Disallowed Inputs
    </a>
  </li>
{% endblock %}

{% block exploits %}
  <pre class="bash">
    # Expert mode

    # Query systemHealth directly by calling /graphql and supplying an arbitrary operation name.

    requests.post('http://host/graphql', json={"query":"query BypassMe{systemHealth}"}, headers={'X-DVGA-MODE':'Expert'})
  </pre>
{% endblock %}
<!-- End -->
